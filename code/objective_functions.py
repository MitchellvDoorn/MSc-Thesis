import numpy as np
import tensorflow as tf
import tensorflow_probability as tfp
import inspect
import ast
import textwrap
from abc import ABC, abstractmethod
from function import Function

class Objective(Function):

    def __init__(self,
                 data,
                 mass_included):

        self._entries = len(data['initial_state'])
        self._initial_tensor = tf.convert_to_tensor(np.array([data['final_state']]), tf.float32)
        self.mass_included = mass_included

        super().__init__(data)

        class Function(ABC):
            '''
            Base class for any type of function used during DeepXDE training
            that requires only (x,y) - like input, while also requiring additional
            parameters
            '''

            def __init__(self, attribute_dict):
                '''
                Initialize the function with the data
                '''

                # Unpack all (kay, value) paris  in the dict as attributes
                for key, value in attribute_dict.items():
                    setattr(self, key, value)

                self._check_call_method()

            @abstractmethod
            def call(self):
                '''
                Enforce the existance of the call method
                '''
                pass

            @classmethod
            def get_attributes(cls, instance):
                '''
                Return al user defined attributes
                '''

                attributes = {}
                for attr in dir(instance):
                    if attr != '_abc_impl' and not attr.startswith('__') and not callable(getattr(instance, attr)):
                        attributes[attr] = getattr(instance, attr)
                return attributes

            def _check_call_method(self):
                '''
                Generated by ChatGPT. Checks whether the child method "call" exists and
                if all required variables existed in the attribute_dict
                '''
                child_instance = self
                call_method = getattr(child_instance, 'call', None)

                if call_method and inspect.ismethod(call_method):
                    call_method_source = inspect.getsource(call_method)
                    required_attributes = self._get_required_attributes(call_method_source)

                    for attribute in required_attributes:
                        if not hasattr(child_instance, attribute):
                            raise AttributeError(f"{type(self).__name__}.call is requiring attribute: {attribute}")
                else:
                    raise AttributeError(f"{type(self).__name__} class does not have a valid `call` method.")

            def _get_required_attributes(self, method_source):
                '''
                Generated by ChatGPT. Retrieves als attributes being used in
                the childs 'call' method
                '''

                method_source = textwrap.dedent(method_source)
                method_ast = ast.parse(method_source)
                required_attributes = []

                for node in ast.walk(method_ast):
                    if (
                            isinstance(node, ast.Attribute)
                            and isinstance(node.value, ast.Name)
                            and node.value.id == 'self'
                    ):
                        attribute_name = node.attr
                        if attribute_name not in required_attributes:
                            required_attributes.append(attribute_name)

                return required_attributes

class OptimalFuel(Objective):

    def call(self, t, y, losses):
        '''
        Calculate consumed mass by integrating the thrust profile.
        Requires a whole batch of input/output pairs.
        '''
        # Get control and calculate norm
        time_scale = 5022642.890911884
        t = tf.reshape(t, (1, -1))[0] * time_scale
        # t = tf.reshape(t, (1, -1))[0] * self.time_scale

        # if self.mass_included:
        #     U = y[:, self._entries:-1]
        # else:
        #     U = y[:, self._entries:]
        U = y[:, 4:6]

        U_norm = tf.norm(U, axis=1)

        # Sort time and control
        idx = tf.argsort(t)
        t_sorted = tf.gather(t, idx)
        U_norm_sorted = tf.gather(U_norm, idx)

        # Propellent mass
        propellent_mass = (1/2500/9.81) * tfp.math.trapz(U_norm_sorted, t_sorted)
        # propellent_mass = (1/self.isp/9.81) * tfp.math.trapz(U_norm_sorted, t_sorted)
        return propellent_mass


